import { format } from 'date-fns';

/**
 * Markdown Generator Utilities
 *
 * This module provides template functions for generating structured markdown
 * documents from threads, reports, and other entities. The output is:
 * - Human-readable and well-formatted
 * - AI-parseable with clear structure
 * - SEO-friendly with proper headings and metadata
 */

export interface ThreadData {
  _id: string;
  title: string;
  description?: string;
  status: string;
  createdAt: Date;
  updatedAt: Date;
  userId: string;
}

export interface MessageData {
  _id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  createdAt: Date;
  metadata?: {
    model?: string;
    tokens?: number;
  };
}

export interface ReportData {
  _id: string;
  title?: string;
  htmlContent: string;
  createdAt: Date;
  isInteractiveMode?: boolean;
  metadata?: {
    model?: string;
    tokens?: number;
  };
}

export interface SectionData {
  _id: string;
  title: string;
  htmlContent: string;
  order: number;
  type: string;
  createdAt: Date;
}

/**
 * Generate slug from title
 */
export function generateSlug(title: string, id: string): string {
  const slug = title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

  // Add first 8 chars of ID for uniqueness
  return `${slug}-${id.substring(0, 8)}`;
}

/**
 * Format date for markdown
 */
export function formatDate(date: Date): string {
  return format(new Date(date), 'MMMM d, yyyy \'at\' h:mm a');
}

/**
 * Convert HTML to markdown-friendly text
 * This is a simple converter - for production, consider using a library like turndown
 */
export function htmlToMarkdown(html: string): string {
  return html
    // Remove script and style tags
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
    // Convert headings
    .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n\n')
    .replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\n\n')
    .replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\n\n')
    .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\n\n')
    // Convert paragraphs
    .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\n\n')
    // Convert lists
    .replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n')
    .replace(/<ul[^>]*>(.*?)<\/ul>/gi, '$1\n')
    .replace(/<ol[^>]*>(.*?)<\/ol>/gi, '$1\n')
    // Convert links
    .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)')
    // Convert bold and italic
    .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
    .replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**')
    .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
    .replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*')
    // Convert line breaks
    .replace(/<br\s*\/?>/gi, '\n')
    // Remove remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    // Clean up extra whitespace
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

/**
 * Generate Thread Context Snapshot
 */
export function generateThreadSnapshot(
  thread: ThreadData,
  messages: MessageData[],
  reports: ReportData[],
  systemPromptName?: string
): string {
  const markdown = `# ${thread.title} - AssetWorks Context Snapshot

**Type**: Thread Context
**Created**: ${formatDate(thread.createdAt)}
**Last Updated**: ${formatDate(thread.updatedAt)}
**Status**: ${thread.status}

---

## 📊 Overview

This thread contains a conversation focused on financial analysis and reporting. The discussion includes ${messages.length} message(s) and has generated ${reports.length} report(s).

**Statistics**:
- **Messages**: ${messages.length}
- **Reports Generated**: ${reports.length}
- **Sections**: ${reports.reduce((total, r) => total + (r.isInteractiveMode ? 1 : 0), 0)}
- **AI Model**: ${messages.find(m => m.metadata?.model)?.metadata?.model || 'Claude 3.5 Sonnet'}
${systemPromptName ? `- **System Prompt**: ${systemPromptName}` : ''}

---

## 💬 Chat History

${generateMessagesSection(messages)}

---

## 📄 Reports Generated

${generateReportsSection(reports)}

---

## 🔍 Metadata

- **Thread ID**: \`${thread._id}\`
- **Created**: ${formatDate(thread.createdAt)}
- **Last Updated**: ${formatDate(thread.updatedAt)}
- **Status**: ${thread.status}

---

*Last updated: ${formatDate(new Date())} | Generated by AssetWorks AI*
*Visit [AssetWorks](https://assetworks.ai) for more financial intelligence.*
`;

  return markdown;
}

/**
 * Generate messages section
 */
function generateMessagesSection(messages: MessageData[]): string {
  if (messages.length === 0) {
    return '*No messages yet.*';
  }

  return messages
    .map((message, index) => {
      const roleEmoji = message.role === 'user' ? '👤' : '🤖';
      const roleLabel = message.role === 'user' ? 'User' : 'Assistant';
      const timestamp = formatDate(message.createdAt);

      return `### ${roleEmoji} ${roleLabel} - ${timestamp}

${message.content}

${message.metadata?.tokens ? `*Tokens: ${message.metadata.tokens}*` : ''}
`;
    })
    .join('\n---\n\n');
}

/**
 * Generate reports section
 */
function generateReportsSection(reports: ReportData[]): string {
  if (reports.length === 0) {
    return '*No reports generated yet.*';
  }

  return reports
    .map((report, index) => {
      const reportNumber = index + 1;
      const title = report.title || `Report ${reportNumber}`;
      const timestamp = formatDate(report.createdAt);
      const content = htmlToMarkdown(report.htmlContent);

      // Truncate content if too long (keep first 500 chars)
      const contentPreview =
        content.length > 500 ? content.substring(0, 500) + '...' : content;

      return `### Report ${reportNumber}: ${title}

**Generated**: ${timestamp}
**Mode**: ${report.isInteractiveMode ? 'Interactive' : 'Standard'}
${report.metadata?.model ? `**Model**: ${report.metadata.model}` : ''}

${contentPreview}
`;
    })
    .join('\n---\n\n');
}

/**
 * Generate Report Context Snapshot
 */
export function generateReportSnapshot(
  report: ReportData,
  sections: SectionData[],
  threadTitle?: string
): string {
  const reportTitle = report.title || 'Financial Report';
  const timestamp = formatDate(report.createdAt);

  const markdown = `# ${reportTitle} - AssetWorks Report

**Type**: Report Context
**Generated**: ${timestamp}
**Mode**: ${report.isInteractiveMode ? 'Interactive' : 'Standard'}
${threadTitle ? `**Thread**: ${threadTitle}` : ''}

---

## 📊 Report Summary

${generateReportSummarySection(report, sections)}

---

## 📝 Report Sections

${generateSectionsDetail(sections)}

---

## 🔍 Metadata

- **Report ID**: \`${report._id}\`
- **Created**: ${timestamp}
- **Interactive Mode**: ${report.isInteractiveMode ? 'Yes' : 'No'}
- **Total Sections**: ${sections.length}
${report.metadata?.model ? `- **AI Model**: ${report.metadata.model}` : ''}

---

*Last updated: ${formatDate(new Date())} | Generated by AssetWorks AI*
*Visit [AssetWorks](https://assetworks.ai) for more financial intelligence.*
`;

  return markdown;
}

/**
 * Generate report summary section
 */
function generateReportSummarySection(
  report: ReportData,
  sections: SectionData[]
): string {
  const content = htmlToMarkdown(report.htmlContent);
  const wordCount = content.split(/\s+/).length;

  return `This report contains ${sections.length} section(s) with approximately ${wordCount} words.

**Content Overview**:
${content.substring(0, 300)}${content.length > 300 ? '...' : ''}
`;
}

/**
 * Generate detailed sections
 */
function generateSectionsDetail(sections: SectionData[]): string {
  if (sections.length === 0) {
    return '*No sections available.*';
  }

  return sections
    .sort((a, b) => a.order - b.order)
    .map((section, index) => {
      const content = htmlToMarkdown(section.htmlContent);
      const timestamp = formatDate(section.createdAt);

      return `### ${section.order + 1}. ${section.title}

**Type**: ${section.type}
**Created**: ${timestamp}

${content}
`;
    })
    .join('\n---\n\n');
}

/**
 * Generate SEO metadata from content
 */
export function generateSEOMetadata(
  title: string,
  content: string,
  entityType: 'thread' | 'report'
): {
  title: string;
  description: string;
  keywords: string[];
} {
  // Extract keywords from content (simple approach)
  const words = content.toLowerCase().match(/\b[a-z]{4,}\b/g) || [];
  const wordFrequency = words.reduce((acc, word) => {
    acc[word] = (acc[word] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const keywords = Object.entries(wordFrequency)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 10)
    .map(([word]) => word);

  // Generate description (first 160 chars of clean content)
  const cleanContent = content.replace(/[#*\-_]/g, '').trim();
  const description =
    cleanContent.length > 160
      ? cleanContent.substring(0, 157) + '...'
      : cleanContent;

  return {
    title: `${title} | AssetWorks ${entityType === 'thread' ? 'Thread' : 'Report'}`,
    description,
    keywords: ['assetworks', 'financial', 'ai', entityType, ...keywords],
  };
}

/**
 * Anonymize user data for public snapshots
 */
export function anonymizeContent(content: string, userId: string): string {
  // Replace user ID with generic identifier
  const anonymized = content.replace(
    new RegExp(userId, 'g'),
    'user_[anonymized]'
  );

  // Remove email patterns
  return anonymized.replace(
    /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
    '[email protected]'
  );
}
